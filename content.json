{"meta":{"title":"lollipop的博客","subtitle":null,"description":null,"author":"lollipop","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2018-09-20T15:36:14.000Z","updated":"2018-10-07T07:29:13.178Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMvc项目配置多数据源","slug":"项目配置多数据源","date":"2019-10-14T16:39:59.000Z","updated":"2019-10-14T16:47:23.237Z","comments":true,"path":"2019/10/15/项目配置多数据源/","link":"","permalink":"http://yoursite.com/2019/10/15/项目配置多数据源/","excerpt":"SpringMvc项目配置多数据源","text":"SpringMvc项目配置多数据源 1. 首选添加另外的数据源 数据源配置在dbconfig.properties文件 123456789#db1db1.url=jdbc:mysql://localhost:3306/db1db1.username=rootdb1.password=123456##db2db2.url=jdbc:mysql://localhost:3306/db2db2.username=rootdb2.password=123456 2.在springmvc配置文件中增加对第二个数据源的支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!-- 阿里 druid数据库连接池 --&gt;&lt;!-- 这是第一个数据源 --&gt; &lt;bean id=&quot;db1&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 数据库基本信息配置 --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;db1.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;db1.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db1.password&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassName&#125;&quot;/&gt; &lt;property name=&quot;filters&quot; value=&quot;$&#123;filters&#125;&quot;/&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;/&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;/&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;timeBetweenEvictionRunsMillis&#125;&quot;/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;minEvictableIdleTimeMillis&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;validationQuery&#125;&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;$&#123;testWhileIdle&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;testOnBorrow&#125;&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;$&#123;testOnReturn&#125;&quot;/&gt; &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;$&#123;maxOpenPreparedStatements&#125;&quot;/&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;$&#123;removeAbandoned&#125;&quot;/&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;$&#123;removeAbandonedTimeout&#125;&quot;/&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;$&#123;logAbandoned&#125;&quot;/&gt; &lt;property name=&quot;connectionInitSqls&quot; value=&quot;set names utf8mb4;&quot;/&gt; &lt;/bean&gt; &lt;!-- 阿里 druid数据库连接池 --&gt; &lt;!-- 这是第二个数据源 --&gt; &lt;bean id=&quot;db2&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;!-- 数据库基本信息配置 --&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;db2.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;db2.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db2.password&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassName&#125;&quot;/&gt; &lt;property name=&quot;filters&quot; value=&quot;$&#123;filters&#125;&quot;/&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;/&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;$&#123;maxWait&#125;&quot;/&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;timeBetweenEvictionRunsMillis&#125;&quot;/&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;minEvictableIdleTimeMillis&#125;&quot;/&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;$&#123;validationQuery&#125;&quot;/&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;$&#123;testWhileIdle&#125;&quot;/&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;testOnBorrow&#125;&quot;/&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;$&#123;testOnReturn&#125;&quot;/&gt; &lt;property name=&quot;maxOpenPreparedStatements&quot; value=&quot;$&#123;maxOpenPreparedStatements&#125;&quot;/&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=&quot;removeAbandoned&quot; value=&quot;$&#123;removeAbandoned&#125;&quot;/&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;$&#123;removeAbandonedTimeout&#125;&quot;/&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=&quot;logAbandoned&quot; value=&quot;$&#123;logAbandoned&#125;&quot;/&gt; &lt;property name=&quot;connectionInitSqls&quot; value=&quot;set names utf8mb4;&quot;/&gt; &lt;/bean&gt; 这时候项目已经有两个数据源了。但是什么时候选择哪个数据源，我们还要告诉程序，告诉指定哪一个数据源。需要继承spring给我们提供的AbstractRoutingDataSource类。在我们需要动态切换另外的数据源时，可以提供设置指定数据源。但需要确保不同线程中的数据源不互相干扰。这时可以利用ThreadLocal在同一个线程中传递上下文信息，达到多数据源访问的效果。1234567//MultiDataSource.java public class MultiDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DatabaseContentHolder.getDataSource(); &#125;&#125; 定义枚举类来枚举数据源1234public enum DBSource &#123; DB1(), DB2()&#125; 1234567891011121314151617181920public class DatabaseContentHolder &#123; //用ThreadLocal来设置当前线程使用哪个dataSource private static final ThreadLocal&lt;DBSource&gt; contextHolder = new ThreadLocal&lt;&gt;(); public static void setDataSource(DBSource DBSource) &#123; contextHolder.set(DBSource); &#125; public static DBSource getDataSource() &#123; DBSource DBSource = contextHolder.get(); if (DBSource == null) return DBSource.DB1; return DBSource; &#125; public static void remove() &#123; contextHolder.remove(); &#125;&#125; 在spring 配置文件中注册数据源.map内的key需要跟数据源枚举类中定义的值相同，value-ref的值需要跟spring配置中定义的数据源的id相同。1234567891011&lt;!--多数据源配置--&gt; &lt;bean id=&quot;multiDataSource&quot; class=&quot;com.***.MultiDataSource&quot;&gt; &lt;property name=&quot;targetDataSources&quot;&gt; &lt;map key-type=&quot;com.***.DBSource&quot;&gt; &lt;entry value-ref=&quot;db1&quot; key=&quot;DB1&quot;/&gt; &lt;entry value-ref=&quot;db2&quot; key=&quot;DB2&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;defaultTargetDataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 注册好数据源，还要把数据源绑定到mybaits和事务中。1234567891011&lt;bean name=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;multiDataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置mybatis --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;multiDataSource&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;!-- mapper扫描 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mybatis/*/*.xml&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 这样多数据源就配置完成了。如果不指定数据源，默认使用db1的数据源，如果需要动态切换到db2，则需要手动调用DatabaseContentHolder.setDataSource(DBSource.DB2)来告知这个线程都采用db2的数据源。 3.利用aop和注解实现自动指定。 先定义一个方法注解1234567//Database.java@Documented@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Database &#123; DBSource source() default DBSource.READ_WRITE;&#125; 然后利用aop，在加入该注解的方法前调用DatabaseContentHolder.setDataSource(DBSource.DB2)123456789101112131415161718192021222324@Aspect@Componentpublic class DatabaseAspect &#123; @Pointcut(&quot;@annotation(com.***.Database)&quot;) public void aspect() &#123; &#125; @Before(&quot;aspect()&quot;) public void doBefore(JoinPoint joinPoint) &#123; Signature signature = joinPoint.getSignature(); MethodSignature methodSignature = (MethodSignature) signature; Method method = methodSignature.getMethod(); if (method.isAnnotationPresent(Database.class)) &#123; Database database = method.getAnnotation(Database.class); DatabaseContentHolder.setDataSource(database.source()); &#125; &#125; @AfterReturning(pointcut = &quot;aspect()&quot;) public void doAfter(JoinPoint joinPoint) &#123; DatabaseContentHolder.remove(); &#125;&#125; 这样，如果方法没有Database注解，就默认调用db1连接，如果添加了@Database(source = DBSource.ONLY_READ)注解则调用db2","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Idea热部署插件Jrebel的安装与使用","slug":"Idea热部署插件Jrebel的安装与使用","date":"2018-11-07T13:33:34.000Z","updated":"2018-11-07T14:10:40.887Z","comments":true,"path":"2018/11/07/Idea热部署插件Jrebel的安装与使用/","link":"","permalink":"http://yoursite.com/2018/11/07/Idea热部署插件Jrebel的安装与使用/","excerpt":"","text":"JRebel 能做什么？JRebel 是一款热部署插件。当你的 java-web 项目在 Tomcat 中 run/debug 的时候 ,修改某一个 java 文件时，tomcat 并不能将此文件的修改 实时编译 并反映到运行的项目中去。JRebel 就可以解决在项目运行状态run/debug 状态下任意修改 java 文件并动态反馈到运行的项目中。 JRebel 插件 获取与安装在Idea中在线获取JRebel插件并安装。打开Setting(Ctrl+Alt+S)-Plugins,搜索JRebel。Install 后重启。 JRebel 插件 破解打开Setting(Ctrl+Alt+S)-JRebel,点击Activate now。 点击I already have a license ,输入激活地址和邮箱，勾选Agree,完成激活。 2018.11.7可用激活地址http://139.199.89.239:1008/b8fdf475-b9f7-4146-b426-6e1bb5a17a16(参考链接：Jrebel最新激活破解方式(持续更新)) 打开Setting(Ctrl+Alt+S)-JRebel,点击Work offline 关闭联网检测。 自此JRebel 激活完成。 JRebel 插件使用点击这两个按钮，左侧为run，右侧为debug。 当java文件发生改变，则可以Shirt+F10重新热部署。","categories":[],"tags":[{"name":"IDEA使用","slug":"IDEA使用","permalink":"http://yoursite.com/tags/IDEA使用/"}]},{"title":"从MyEclipse导入项目到Idea","slug":"从MyEclipse导入项目到Idea","date":"2018-10-25T10:54:40.000Z","updated":"2018-11-07T14:10:06.986Z","comments":true,"path":"2018/10/25/从MyEclipse导入项目到Idea/","link":"","permalink":"http://yoursite.com/2018/10/25/从MyEclipse导入项目到Idea/","excerpt":"","text":"导入项目到IdeaFile – New - project from existing sources,选择项目位置 选择Eclispe，然后一直Next 配置项目File – Project Structure 选择Project，选择输出路径 把默认路径改成WebRoot\\WEB-INF\\classes文件夹 选择Moduel，把红色的取消选择。 然后选择Java SDK 选择Facets,点击上方 + 号，选择Web 弹窗选OK，然后修改红框内两个路径 上面那个修改为项目内WebRoot\\WEB-INF\\web.xml，下面那个修改为项目内WebRoot文件夹 配置Tomcat点击Add Configuration，添加Tomcat服务 点击fix 选择Artifacts – Web Application：Explored – From Modules 修改路径为Tomcat下Webapps/项目名 保存后回去，选中web explode，并在右侧路径改为 /项目名。 保存后运行即可","categories":[],"tags":[{"name":"IDEA使用","slug":"IDEA使用","permalink":"http://yoursite.com/tags/IDEA使用/"}]},{"title":"Android7.0+多语言适配","slug":"Android7-0-多语言适配","date":"2018-10-08T15:23:52.000Z","updated":"2018-10-08T15:44:19.230Z","comments":true,"path":"2018/10/08/Android7-0-多语言适配/","link":"","permalink":"http://yoursite.com/2018/10/08/Android7-0-多语言适配/","excerpt":"","text":"参考链接:Android 7.0与6.0多语言效果对比以及遇到的坑Android7.0以上 设置多个系统语言导致的国际化问题Android 7.0 语言设置爬坑Android国际化(多语言)实现，支持8.0Android的国际化及开发中遇到的问题解决[全]","categories":[],"tags":[{"name":"Android开发","slug":"Android开发","permalink":"http://yoursite.com/tags/Android开发/"}]},{"title":"RSA算法详解","slug":"RSA算法详解","date":"2018-09-30T04:12:16.000Z","updated":"2018-10-08T15:03:36.119Z","comments":true,"path":"2018/09/30/RSA算法详解/","link":"","permalink":"http://yoursite.com/2018/09/30/RSA算法详解/","excerpt":"","text":"原文地址：安全体系（二）——RSA算法详解 概述 RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA算法以他们三人姓氏开头字母命名。 RSA是目前最有影响力的公钥加密算法，到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要秘钥长度足够长，用RSA加密的信息实际上是不能被解破的。ISO推荐它为公钥数据加密标准。 RSA算法基于简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA是”非对称加密算法”，非对称加密算法需要两个密钥： 公开密钥（publickey）和私有密钥（privatekey） 。公钥与私钥是配对的，用公钥加密的数据只有配对的私钥才能解密，反之亦然。因加解密使用两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称算法的在应用的过程如下，假设发送方向接收方发送消息（明文）： 1.接收方生成公钥和私钥，公钥公开，私钥保留； 2.发送方将要发送的消息采用公钥加密，得到密文，然后将密文发送给接收方； 3.接收方收到密文后，用自己的私钥进行解密，获得明文。 可以看出，非对称加密解决了对称加密密钥传输的问题。 数学基础 RSA加密算法中，只用到素数、互质数、欧拉函数、模运算等简单的数学知识。 互质关系1.素数 素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。2.互质数 公因数只有1的两个数，叫做互质数；又称互素，若N个整数的最大公因子是1，则称这N个整数互质。判断互质的简单法则： a.任意两个质数是互质的； b.一个数是质数，另一个数不是它的倍数，两者互质（比如正整数P是质数，则小于P的正整数和P都是互质的）； c.两个不相等的数，较大的那个数是质数，两者互质； d.1和任意自然数互质； e.2和任何奇数是互质； f.如果P是大于1的整数，则P和P-1互质； g.如果P是大于1的奇数，则P和P-2互质。 欧拉函数欧拉函数的推导： 任意给定正整数n，求在小于等于n的正整数中，有多少个与n互质的正整数？推导步骤如下： a.当n=1时，φ(1)=1（2.1中的d）； b.n为质数时，φ(n)=n-1（2.1中的b）； c.如果n是某一质数的m次方，即n=pm（p为质数，m为整数且大于等于1），则 φ(pm)=pm-pm-1=pm(1-1/p) 这个式子是如何得到的呢？ 当m=1时，同情况b。 根据2.1的b，p是质数，则从1到pm的整数中，除去pk(m≥k≥1)，余下的都与pm互质，页就是说，一共n(其中n=pm)个数，其中有pm-1(即p,p2,…pm)个整数与n不是互质关系，则与n互质的整数个数为pm-pm-1。 d.当n=p1*p2，且p1、p2互质时，有φ(n)= φ(p1p2)=φ(p1) φ(p2) 即积的欧如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1) φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1) φ(p2)。拉函数等于各个因子的欧拉函数的积。e.对于任意一个大于1的正整数，都可以写成n=p1k1p2k2…prkr，其中，p1,p2,…,pk为质数。 由d可知φ(n)= φ(p1k1)φ(p2k2)…φ(prkr) 再由c可知φ(n)= p1k1p2k2…prkr(1-1/p1)(1-1/p2)…(1-1/pr) 即 φ(n)=n(1-1/p1)(1-1/p2)…(1-1/pr) 这就是欧拉函数的通用计算公式 。### 欧拉定理欧拉定理： 如果两个正整数a和n互质，则n的欧拉函数φ(n)可使下面等式成立aφ(n)≡1(mod n) 上式表示，a的φ(n)次方被n除的余数为1，或者叙述为，a的φ(n)次方减去1后可以被n整除。注意，φ(n)是n的欧拉函数。 欧拉定理的特殊情况：如果正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成就是我们所说的费马小定理ap-1≡1(mod p) 模反元素模反元素： 如果两个正整数a和n互质，那么一定可以找到整数b，使得ab-1被n整除，或者说ab被n除的余数是1。这时b被称为a的模反元素。公式如下： ab≡1(mod n) 注意，模反元素并不唯一，如果b是a的模反元素，则b+kn都是a的模反元素。 欧拉定理可以用来证明模反元素的必然存在：aφ(n)= a×aφ(n)-1≡1(mod n) 扩展欧几里得算法 用来计算秘钥的d和e，这里不详细介绍，可参考扩展欧几里得算法。 秘钥的生成与加解密密钥的生成密钥生成的步骤如下： 1.随机选择两个不相等的质数p和q； 2.计算p和q的乘积n（将n转换为二进制后，二进制的长度就是密钥的长度，实际应用中一般选择1024位、2048位）； 3.计算n的欧拉函数φ(n)； 4.随机选择一个整数e，其中φ(n)&gt;e&gt;1，且e与φ(n)互质（实际应用中e一般选为65537）； 5.计算e对于φ(n)的模反元素d； 6.将n和e封装成公钥，n和d封装成私钥。 举例： 1.随机选择两个不相等的质数47和59； 2.二者的乘积为43×57=2773，2773转化为二进制为1010,1101,0101，长度为12位，所以密钥的长度为12位； 3.根据欧拉函数公式φ(n)=n(1-1/p)(1-1/q)计算，φ(2773)=2773×(1-1/47)(1-1/59)=(47-1)(59-1)=2668； 4.随机选择一个整数e=63，2668&gt;63&gt;1，并且63与2668互质； 5.计算63对于2668的模反元素d，根据公式ed≡1(mod φ(n))，有63d-1=2668k，由欧几里得扩展公式计算得d=847。 6.公钥(n,e)=(2773,63)，私钥(n,d)=(2773,847)。 加密和解密1加密 假设发送方向接收方发送信息m，m未加密，我们称之为明文。发送方从接收方获得的公钥为(n,e)，加密公式为 me=c(mod n) 其中，m必须是整数，而且m必须比n小。 m,e,n已知，从上面的公式中计算出c，c就是加密后的信息，我们称之为密文。发送方将密文发送给接收方。 2.解密 接收方从发送方接收到密文c，用自己的配对私钥(n,d)进行解密，解密公式为 cd=m(mod n) 已知c,n,d，从上面公式中计算出m，就是发送方发过来的明文。 举例：1.加密 根据上面计算出的公钥(n,e)=(2773,63)，假如m=244，根据公式me=c(mod n)，可计算出密文c=465。2.解密 根据上面计算出的私钥(n,d)=(2773,847)，已知c=465，根据公式cd=m(mod n)，可计算出明文m=244。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"利用GitHub + Hexo 搭建个人博客","slug":"利用GitHub-Hexo-搭建个人博客","date":"2018-09-26T15:20:33.000Z","updated":"2018-10-07T07:29:13.176Z","comments":true,"path":"2018/09/26/利用GitHub-Hexo-搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/09/26/利用GitHub-Hexo-搭建个人博客/","excerpt":"","text":"HexoHexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。 准备工作1.一个GitHub帐号2.安装Node.js运行环境。Node.js配置教程和下载地址.3.安装git 开始搭建","categories":[],"tags":[]},{"title":"Lua之面向对象个人总结","slug":"Lua之面向对象个人总结","date":"2018-09-20T15:42:04.000Z","updated":"2018-10-07T07:29:13.175Z","comments":true,"path":"2018/09/20/Lua之面向对象个人总结/","link":"","permalink":"http://yoursite.com/2018/09/20/Lua之面向对象个人总结/","excerpt":"面向对象的三个特征：封装、继承和多态。Lua并没有类，没有直接实现面向对象的方法。不过Lua的Table，有内部对象和内部方法。Lua的面向对象主要是通过Table来模拟面向对象。","text":"面向对象的三个特征：封装、继承和多态。Lua并没有类，没有直接实现面向对象的方法。不过Lua的Table，有内部对象和内部方法。Lua的面向对象主要是通过Table来模拟面向对象。 封装在Lua之Table学习中，曾以Computer为例子，介绍了Table 也是可以有自己内部的属性和方法。 1234567891011121314local CPU = &#123; name = &apos;CPU&apos;, cost = 400 &#125;local Monitor = &#123; name = &apos;bird&apos;, cost = 200 &#125;local Memory = &#123; name = &apos;memory&apos;, cost = 100 &#125;local Computer = &#123; description = &quot;this is a computer&quot;, cpu = CPU, monitor = Monitor, memory = Memory&#125;function Computer.getDescription() return Computer.descriptionendprint(Computer.getDescription())&gt; 上面的代码有几个问题1、没有构造函数，没办法实例化对象2、内部的方法更像Java中的静态方法，不需要有具体对象都能够调用。内部的成员更像静态成员。123456789101112131415161718192021222324252627local Computer=&#123;&#125;Computer.cpu = &#123; name = &apos;cpu&apos;,cost = 400 &#125;Computer.memory = &#123;name = &apos;memory&apos;,cost = 200 &#125;Computer.monitor = &#123;name = &apos;monitor&apos;,cost = 100 &#125;Computer.description = &apos;this is a computer&apos;function Computer:getDescription() --内部方法 print(self.description)endfunction Computer:new () --构造函数 t = &#123;&#125; setmetatable(t, &#123; __index = self &#125;) return tendfunction Computer:getCost() --内部方法 cost = self.cpu.cost + self.memory.cost + self.monitor.cost print(self.description..&apos;:cost &apos;.. cost)endc1=Computer:new()c1.description = &apos;this is c1&apos; --改变Computer实例化对象内部的descriptionc1:getDescription()c1:getCost()c2=Computer:new()c2.memory.cost = 900 --改变Computer实例化对象内部的memory.costc2:getDescription()c2:getCost() 输出1234this is c1 this is c1:cost 700 --c2的memory.cost改变，c1不受影响this is a computer --c1的description改变，c2不受影响this is a computer:cost 1400 改良后的代码，有了构造函数，能够实例化对象。上面实例化了两个对象c1和c2，内部成员相互独立，无法相互影响。 访问成员使用点访问类内成员1c1.description = &apos;this is c1&apos; 成员函数12345678function getCost() --普通函数 --do somethingendfunction Computer:getCost() --成员函数， cost = self.cpu.cost + self.memory.cost + self.monitor.cost print(self.description..&apos;:cost &apos;.. cost)end 普通函数只需要function修饰就可以了，成员函数除了function 关键字还需要声明属于某个类。前面的Computer 表示这个是Computer 类的成员函数。之间需要用冒号(:)来连接。成员函数内部的self相当于Java 的this，表示实例对象自身。如果用普通函数声明为成员函数，调用自身成员需要传入self123function Computer.getDescription(self) --成员函数 print(self.description)end 实例对象访问成员函数通过冒号(:)访问，也可以通过点号(.)访问，后者访问时候需要传入self，即自身12345678910111213function Computer.getDescription(self) print(self.description)endfunction Computer:getCost() cost = self.cpu.cost + self.memory.cost + self.monitor.cost print(self.description .. &apos;:cost &apos; .. cost)endc1:getCost() c1.getCost(c1)c1:getDescription()c1.getDescription(c1) 输出1234this is c1:cost 700 this is c1:cost 700 --只用冒号(:)式声明getCost()，用点式(.)传入自身也能访问this is c1 --只用点式(.)式声明getCost()，用冒号(:)式不传参也能访问this is c1 可以看到两种成员函数声明方式是等价的，使用也是等价的。 构造函数使用构造函数来为类的实例分配内存，每个类都有属于自己的内存并共享公共数据。12345function Computer:new () --构造函数 t = &#123;&#125; setmetatable(t, &#123; __index = self &#125;) return tend 构造函数本质上也是成员函数，同时需要使用关键字new 来说明这是一个构造函数。为什么要用元表来构造呢，不能直接return self呢，下面举个例子，构造函数直接返回self12345678910111213141516local Computer = &#123;&#125;Computer.description = &apos;this is a computer&apos;function Computer:getDescription() print(self.description)endfunction Computer:new() return selfendc1 = Computer:new()c1.description = &apos;this is c1&apos;c1:getDescription()c2 = Computer:new()c2:getDescription() 输出12this is c1this is c1 按照思维，只改变了c1的description，c1和c2是独立的对象，c2应该不受影响才对。编译过程也没有报错，但是c2的description也被改变了。如果我们把self本身也看做一块独立的内存，实例化c1的时候，构造函数返回self，c1 -&gt; self,对象c1指向self的内存位置。在实例化c2的时候，构造函数也返回了self，c2也指向了self。改变c1的description，实质改变了self的description，这样c2读取的description，也受到了改变。 如何正确地构造对象呢12345function Computer:new() t = &#123;&#125; setmetatable(t, &#123; __index = self &#125;) return tend 这个构造函数，先是构造了一个空表t，然后把self传入到__index元方法，作为元表。最后返回t对象。 Lua查找一个表元素时的规则，其实就是如下3个步骤:1.在表中查找，如果找到，返回该元素，找不到则继续2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。3.判断元表有没有__index 方法，如果__index 方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。 Lua的“面向对象”，实质上是利用表和元表制造的一层层“嵌套关系”。c1.description = &#39;this is c1&#39;这行函数，本质上没有改变self的值，而是在c1对象中增加了description这一属性，因为在表中已经找到了，所以就不会访问元表中的description属性，造成‘改写’这现象。而如果访问的是cpu这个属性，因为c1中找不到，会访问元表，然后直到找到为止。如果访问gpu这个不存在的属性，会一直找下去，直到元方法__index为nil时退出。下面的代码应该可以验证这一猜想。123456789101112c1 = Computer:new()print(&apos;before init description&apos;)for k, v in pairs(c1) do print(k, v) endprint(c1.description)c1.description = &apos;this is c1&apos;print(&apos;after init description&apos;)for k, v in pairs(c1) do print(k, v)endprint(c1.description) 输出：在c1.description = &#39;this is c1&#39;前key-value是没有任何输出的，说明c1没有这些东西（不包括元表的部分）,但是又确确实实能输出（因为找不到就会访问元表）。12345before init descriptionthis is a computerafter init descriptiondescription this is c1this is c1 上面是无参的构造函数，如果是有参的，需要在构造函数中同时改变self中的值。1234567891011121314function Computer:new(description) local o = &#123;&#125; setmetatable(o, self) self.__index = self self.description = description return oendc1 = Computer:new(&apos;init description&apos;)print(&apos;c1 before&apos;, c1.description) --c1 before init descriptionc1.description = &apos;this is c1&apos;print(&apos;c1 after&apos;, c1.description) --c1 after this is c1c2 = Computer:new()print(&apos;c2&apos;, c2.description) --c2 nil 继承在介绍Lua封装的时候，说过封装利用的是表与元表之间的‘层层嵌套’关系。这不多不少也体验了继承的思想。Lua的继承正是基于这种‘层层嵌套’的思想。1234567891011121314151617181920212223242526local Shape = &#123;&#125; --定义基类Shape.area = 0 --基类的成员areafunction Shape:new() local s = &#123;&#125; setmetatable(s, self) self.__index = self return sendfunction Shape:getArea() --父类方法，可见子类也能访问 return self.areaendlocal Square = Shape:new() --关键语句，Square继承Shapefunction Square:new(side) --Square的构造函数 local s = &#123;&#125; setmetatable(s, self) self.__index = self --关键语句，元方法__index为空时候不会向元表查找area值 s.side = side or 0 --Square自身定义了成员变量side self.area = side * side --改变基类的area的值 return sendlocal square = Square:new(10)print(&apos;square side&apos;, square.side) --square side 10print(&apos;square area&apos;, square:getArea()) --square area 100 这个例子，定义了一个基类图像Share，拥有成员area，然后正方形Square继承了Share，增加成员变量side，并重写构造函数。派生类拥有父类的方法和属性。对比下Java的实现12345678910111213class Share &#123; double area = 0; double getArea()&#123; return area; &#125;&#125;class Square extends Share &#123; double size; Square(double size) &#123; this.size = size; area = size * size; &#125;&#125; 多态上面例子中，面积的计算放在了构造函数中，总有一点不妥。假装我们对面向对象思想很熟悉了，写出的Java代码应该是这样的12345678910111213141516171819202122232425abstract class Share &#123; double area = 0; abstract void calcArea();&#125;class Square extends Share &#123; double size; Square(double size) &#123; this.size = size; &#125; @Override void calcArea() &#123; area = size * size; &#125;&#125;class Circle extends Share &#123; double radius; Circle(double radius) &#123; this.radius = radius; &#125; @Override void calcArea() &#123; area = 3.14 * radius * radius; &#125;&#125; 通过对calcArea的不同实现，在不同的子类完成不同的计算。这是多态的体现。Lua也可以，子类通过重写父类的方法实现不同的实现。1234567891011121314151617181920212223242526272829local Shape = &#123;&#125;Shape.area = 0function Shape:new() local s = &#123;&#125; setmetatable(s, self) self.__index = self return sendfunction Shape:getArea() return self.areaendlocal Square = Shape:new()function Square:new(side) local s = &#123;&#125; setmetatable(s, self) self.__index = self s.side = side or 0 return sendfunction Square:getArea() return &apos;I am Square s function&apos;, self.side * self.sideendlocal square = Square:new(10)print(&apos;square side&apos;, square.side)print(&apos;square area&apos;, square:getArea()) 上面的代码有两个getArea函数，其中子类Square复写了父类Share的getArea，并按新内容输出。12square side 10square area I am Square s function 100 参考链接lua中类的实现原理和实践Lua 面向对象Lua面向对象编程详解","categories":[],"tags":[{"name":"Lua学习","slug":"Lua学习","permalink":"http://yoursite.com/tags/Lua学习/"}]},{"title":"Lua之Table个人总结","slug":"Lua之Table学习","date":"2018-09-20T09:32:12.000Z","updated":"2018-10-07T07:29:13.175Z","comments":true,"path":"2018/09/20/Lua之Table学习/","link":"","permalink":"http://yoursite.com/2018/09/20/Lua之Table学习/","excerpt":"在lua中Table是数组和集合的混合物。作为数组时，可以使用除了nil以外的值作为索引。","text":"在lua中Table是数组和集合的混合物。作为数组时，可以使用除了nil以外的值作为索引。 Table的构造利用下标来标明元素123456local table = &#123;&#125;table[1]=&apos;hello&apos;table[5]=&apos;world&apos;for i,v in pairs(table)do print(table[i])end 输出121 hello5 world 在Table内部通过索引来声明1234local table = &#123; [1] = &apos;hello&apos;, [5] = &apos;world&apos; &#125;for i, v in pairs(table) do print(table[i])end 输出121 hello5 world 在Table内部不通过索引来声明1234local table = &#123;&apos;hello&apos;,&apos;world&apos;&#125;for k, v in pairs(table) do print(k,v)end 输出121 hello2 world Note: 1，可以看到通过下标标明元素（方法1）和在内部通过索引方式（方法2）构造的table是一样的。如果不声明索引（方法3），则默认为数字，且从1开始。 2，索引可以为字符串。 123456local table = &#123;&#125;table[1]=&apos;hello&apos;table[&quot;skr&quot;]=&apos;world&apos;for k, v in pairs(table) do print(k,v)end 或者是1234local table = &#123; [1] = &apos;hello&apos;, skr = &quot;world&quot; &#125;for k, v in pairs(table) do print(k, v)end 输出121 helloskr world 这时table有点像Java的HashMap，下标作为key。 3，如果索引为数字访问方式为 table[1]如果索引为其他类型，访问方式为 table.skr 或者是 table[‘skr’]（注意 [ ] 内为字符串，两侧有引号） 1234print(table[1]) --输出helloprint(table.skr) --输出worldprint(table[skr]) --输出nil（没有引号，错误）print(table[&apos;skr&apos;]) --输出world（有引号，正确） 4，#运算符 利用#运算符可以获得table中使用数字做key的元素总数。12local table = &#123; [1] = &apos;hello&apos;, skr = &quot;world&quot;, _2 = &quot;123&quot; &#125;print(#table) --输出1，只有索引为1的元素才会被计算，skr和_2都是字符串 Table的其他用法上面的例子可以看到，Lua的Table，索引Key为数字时像Java的ArrayList，索引为字符串的时候像Java的HashMap。Java的HashMap可以存储对象，Lua的Table也可以。12345678910111213local CPU = &#123; name = &apos;CPU&apos;, cost = 400 &#125;local Monitor = &#123; name = &apos;bird&apos;, cost = 200 &#125;local Memory = &#123; name = &apos;memory&apos;, cost = 100 &#125;local Computer = &#123; CPU, cpu = Monitor&#125;Computer.memory = MemoryComputer[6] = Memoryfor k, v in pairs(Computer) do print(k, v.name, v.cost)end 输出12341 CPU 400 --数字索引cpu bird 200 2 --字符串索引6 memory 100 2 --数字索引，构造后添加memory memory 100 4 --字符串索引，构造后添加 Table中利用索引存储Table，这种思想类似面向对象的封装。而对象是由属性和方法组成，在Lua中，对象由Table作属性，function作方法，共同组成对象。123456789101112131415local CPU = &#123; name = &apos;CPU&apos;, cost = 400 &#125;local Monitor = &#123; name = &apos;bird&apos;, cost = 200 &#125;local Memory = &#123; name = &apos;memory&apos;, cost = 100 &#125;local Computer = &#123; description = &quot;this is a computer&quot;, cpu = CPU, monitor = Monitor, memory = Memory&#125;function Computer.getDescription() return Computer.descriptionendprint(Computer.getDescription()) 输出1this is a computer Table的常用方法 这些方法的使用类似Java的静态方法 table.insert(table,pos,value):往table中第pos中插入value的值。如果pos已存在，则往后移动。12345678910print(&apos;before insert&apos;)local tb = &#123; &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;5&apos; &#125;for k, v in pairs(tb) do print(k, v)endtable.insert(tb, 2, &apos;6&apos;)print(&apos;after insert&apos;)for k, v in pairs(tb) do print(k, v)end 输出1234567891011before insert1 12 23 34 5after insert1 12 63 24 35 5 往tb中index=2的地方插入了6，原来index=2的位置变成了3。类似Java的list.add(index,object). 如果没有索引，则往最后的地方插入。类似Java的list.add(object) pos，否则会报错。 table.remove(table,pos):和insert类似table.sort(table, 排序规则)排序规则为自定义排序规则，缺省为升序 下面的例子是定义了一个排序规则为年龄降序的排序。123456789101112131415161718192021local people = &#123; &#123; name = &apos;a&apos;, age = 11 &#125;, &#123; name = &apos;b&apos;, age = 14 &#125;, &#123; name = &apos;c&apos;, age = 12 &#125;, &#123; name = &apos;d&apos;, age = 10 &#125;,&#125;function sortByAge(a, b) return a.age &gt; b.ageendfunction printArray(showText, array) print(showText) for i, v in ipairs(array) do print(v.name, v.age) endendprintArray(&apos;before&apos;, people)table.sort(people, sortByAge)printArray(&apos;after&apos;, people) 其中sortByAge(object1,object2)需要传入两个对象。如果返回true的话就交换位置，由于这里用的是大于，则表示从大到小排序，则为降序。输出结果为：12345678910beforea 11b 14c 12d 10afterb 14c 12a 11d 10 如果改变排序规则，比较名字。使用升序，输出应该为abcd123function sortByName(a, b) return a.name &lt; b.nameend 输出的确为a-b-c-d12345aftera 11b 14c 12d 10 另外，字符串的排序应该是按照首个字符的AscII码排序。123456local people = &#123; &#123; name = &apos;+a&apos;, age = 11 &#125;, &#123; name = &apos;ab&apos;, age = 14 &#125;, &#123; name = &apos;Dc&apos;, age = 12 &#125;, &#123; name = &apos;9d&apos;, age = 10 &#125;,&#125; 其中+的Ascii码为43，a为97，D为68，9为57，输出结果为12345after+a 119d 10Dc 12ab 14 table.concat(table[,间隔符[,start[,end]]])把table内部的元素从start开始到end，以 间隔符 拼接，拼接后的对象属性为String1234567local tb = &#123;&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;&#125;local s1 = table.concat(tb,&apos;*&apos;,2,3)local s2 = table.concat(tb)print(s1)print(type(s1))print(s2)print(type(s2)) 上面展示了把table的每个元素拼接，元素之间以 * 和 ‘’(空字符串) 间隔，输出12342*3 --从第二到第三个元素，期间以*连接string1234 --不带参数表示从头到尾，以空字符串连接string","categories":[],"tags":[{"name":"Lua学习","slug":"Lua学习","permalink":"http://yoursite.com/tags/Lua学习/"}]}]}